Below is a single, comprehensive design specification that you can drop into `docs/design.md`. It consolidates everything we decided, adds senior-level fixes for cracks we identified, and is ready to drive implementation.

---

# Bookmark Runtime: Comprehensive Design Specification

**Status:** Draft v1.0 **Owner:** Tech Lead **Targets:** macOS first, Linux and Windows later **Primary goals:** local-first, private, high performance, publishable

---

## 1. Product scope and goals

### 1.1 Vision

A local-first bookmark manager with an Arc-like folder-centric UX. All data is stored on-device. A single daemon owns the datastore and exposes a small IPC API that platform UIs consume. Versioned history uses Git. No local HTTP. No background network listeners.

### 1.2 v1 feature set

- Nested folders and bookmarks, ordered by drag and drop
- Add, rename, move, delete for folders and bookmarks
- Save current browser window as a folder of bookmarks
- Search by title and URL (case-insensitive substring)
- SQLite as canonical store
- Git repository for versioned history and optional push or pull
- macOS SwiftUI app as primary client
- Optional Safari app extension for quick capture
- Chrome extension via Native Messaging bridge for quick capture
- Local IPC only: Unix domain sockets on macOS and Linux, named pipes on Windows

### 1.3 Non-goals for v1

- Tags, labels, complex metadata
- Notes per bookmark
- Full text search of page content
- Multi-user or sharing
- Perfect multi-device merge with conflict-free structures
- End-to-end encryption

---

## 2. System architecture

### 2.1 Components

- **Core library (`pkg/core`)**: domain model, validation, operations
- **Storage layer (`pkg/storage/sqlite`)**: SQLite persistence and schema migrations
- **VCS layer (`pkg/vcs/git`)**: Git repository lifecycle and commits
- **Daemon (`cmd/bmd`)**: process that owns the profile, storage, and VCS, and exposes IPC
- **IPC transport (`pkg/ipc`)**: framing and request routing over sockets or pipes
- **Browser bridge (`cmd/bmd-bridge`)**: Native Messaging host that relays extension messages to daemon
- **macOS app (`ui/macos`)**: SwiftUI client that speaks IPC
- **Safari extension (`ui/macos/extension`)**: app extension for quick capture
- **Chrome extension (`ui/chrome`)**: MV3 extension that talks to `bmd-bridge`

### 2.2 Processes and deployment model

- One daemon per active profile on a machine
- Daemon runs as:

  - macOS: LaunchAgent for dev and direct distribution, or login item via `SMAppService` for App Store builds
  - Linux: systemd user service
  - Windows: user-level background app or Windows Service
- Clients connect to the profile-specific IPC endpoint
- Only the daemon writes to SQLite and Git

### 2.3 Data flow at a glance

1. Client sends `apply_ops` with a batch of operations
2. Daemon validates the batch, applies it in one SQLite transaction
3. Daemon exports snapshot, commits to Git, emits `tree_changed` event
4. Client updates UI using the returned tree or by re-fetching

---

## 3. Domain model and operations

### 3.1 IDs

- Use ULID for `Node.id` to get time-orderable opaque identifiers
- IDs are generated by the daemon, never by clients

### 3.2 Node model

```ts
type NodeKind = "folder" | "bookmark";

interface Node {
  id: string;
  kind: NodeKind;
  title: string;
  url?: string; // only for bookmarks
  parentId: string | null; // null only for root
  ord: number; // ordering among siblings
  createdAt: number; // unix ms
  updatedAt: number; // unix ms
}
```

### 3.3 Tree model for IPC

```ts
interface Tree {
  version: string; // last commit hash or internal version
  rootId: string;
  nodes: { [id: string]: Node };
  // optional for convenience
  // children are implicit from ord and parentId, but exposing this helps UIs
  children?: { [folderId: string]: string[] };
}
```

### 3.4 Operations (batched)

- `add_folder(parentId, title, index?)`
- `add_bookmark(parentId, title, url, index?)`
- `rename_node(nodeId, title)`
- `update_bookmark(nodeId, title?, url?)`
- `move_node(nodeId, newParentId, newIndex?)`
- `delete_node(nodeId, recursive?)`
- `save_session(parentId, title, tabs[], index?)` where `tabs[]` is list of `{title,url}`

Validation rules:

- Root node is immutable and undeletable
- Parent must exist and must be a folder
- Moves cannot create cycles
- `url` must be http or https
- `newIndex` is clamped to child count
- Duplicate titles allowed in v1, can be tightened later

Batch semantics:

- All ops in a batch are applied in order inside a single transaction
- On any validation error, roll back the entire batch
- Clients should coalesce repetitive gestures (drag reorder, save session, multi-tab capture) into one `apply_ops` call so Git commits stay meaningful and the daemon does not waste cycles on intermediates

---

## 4. Storage design (SQLite canonical)

### 4.1 Pragmas and durability

- `PRAGMA foreign_keys = ON;`
- `PRAGMA journal_mode = DELETE;` (single writer, simpler for Git snapshot)
- `PRAGMA synchronous = FULL;`
- `PRAGMA busy_timeout = 5000;`

### 4.2 Schema v1

```sql
CREATE TABLE IF NOT EXISTS meta (
  key   TEXT PRIMARY KEY,
  value TEXT NOT NULL
);

INSERT OR IGNORE INTO meta(key,value) VALUES ('schemaVersion','1');

CREATE TABLE IF NOT EXISTS nodes (
  id         TEXT PRIMARY KEY,
  parent_id  TEXT REFERENCES nodes(id) ON DELETE CASCADE,
  kind       TEXT NOT NULL CHECK (kind IN ('folder','bookmark')),
  title      TEXT NOT NULL,
  url        TEXT,
  ord        REAL NOT NULL DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_nodes_parent_ord ON nodes(parent_id, ord);
CREATE INDEX IF NOT EXISTS idx_nodes_title_nocase ON nodes(title COLLATE NOCASE);
CREATE INDEX IF NOT EXISTS idx_nodes_url ON nodes(url);
```

### 4.3 Ordering strategy

- `ord` is a floating value
- For insert between A and B, set `ord = (A.ord + B.ord) / 2`
- When gaps become too small, rebalance a folder's children in one transaction
- Default epsilon for triggering a rebalance is `1e-6`. Keep it constant in v1 so every process produces identical ordering math; promote it to config only when production data shows a need.
- Root-level children are those with `parent_id = root`

### 4.4 Lifecycle

- On first run, create `root` folder and a small number of starter `ord` values if desired
- On every successful batch:

  1. Commit SQLite transaction
  2. Export snapshot JSON
  3. Stage and commit to Git

### 4.5 Snapshot JSON (for diffs and export)

```json
{
  "schemaVersion": 1,
  "generatedAt": 1700000100000,
  "version": "abc123",
  "rootId": "root",
  "nodes": { "root": { "...": "..." }, "fld_1": { "...": "..." } },
  "children": { "root": ["fld_1", "fld_2"], "fld_1": ["bm_7", "bm_9"] }
}
```

### 4.6 Migrations

- Keep a Go migration runner
- Bump `meta.schemaVersion` with each migration
- Migrations are idempotent where possible

---

## 5. Version control design (Git)

### 5.1 Repo layout

```
<profile>/repo/
  .git/
  state.db
  snapshot.json
```

### 5.2 Commit policy

- After each successful batch, export snapshot and commit both `state.db` and `snapshot.json`
- Commit message: `apply <n> ops: <short summary>`
- `<short summary>` is auto-derived from the first op kind in the batch (e.g., `add_bookmark`, `move_node`) so clients stay dumb and commit history remains uniform
- Debounce reorder-heavy sequences on the client, or batch them in one request, to reduce noise

### 5.3 Remote sync policy for v1

- Optional remote stored in config
- Push and pull are explicit user actions triggered by CLI or UI invocations; the daemon never syncs in the background
- Fast-forward only enforcement

  - Push fails with `VCS_NOT_FAST_FORWARD` if upstream is ahead
  - Pull fails with `VCS_LOCAL_CHANGES_PRESENT` if local has unpushed commits. Recovery stays manual—users push pending work or run explicit reset flows outside the daemon.
- v1 requires a single active writer per remote
- Multi-device merge will be designed in a later version

### 5.4 Credentials

- Store in platform secure store

  - macOS Keychain
  - Windows Credential Manager
  - Linux libsecret when available, else a file with 0600 and a warning
- Do not expose credentials over IPC

---

## 6. IPC protocol

### 6.1 Transport

- macOS and Linux: Unix domain socket at `<profile>/ipc.sock`
- Windows: named pipe `\\.\pipe\BookmarkRuntime-<profile>`
- Parent directory for socket must have 0700 permissions

### 6.2 Framing and encoding

- 4 byte little-endian length prefix
- UTF-8 JSON payload
- Request-response RPC plus optional server events

### 6.3 Request envelope

```json
{ "id": "client-chosen-id", "type": "rpcMethodName", "params": { ... } }
```

### 6.4 Response envelope

```json
{ "id": "same-id", "ok": true, "result": { ... }, "error": null, "traceId": "..." }
```

On error:

```json
{ "id": "same-id", "ok": false, "result": null, "error": { "code":"...", "message":"...", "details":{...} }, "traceId":"..." }
```

### 6.5 Server events

Unsolicited messages with `"kind": "event"`.

```json
{
  "kind": "event",
  "event": "tree_changed",
  "version": "abc123",
  "changedNodeIds": ["bm_42", "fld_3"]
}
```

Clients that need live updates open a long-lived subscription. `tree_changed` events intentionally ship only identifiers and version metadata; clients issue `get_tree` (or more targeted requests) when they need a fresh snapshot so events stay lightweight and caching policy remains on the UI side.

### 6.6 Methods (v1)

- `get_tree() -> { tree }`
- `apply_ops({ ops: Op[] }) -> { tree, vcsStatus }`
- `search({ query: string, limit?: number }) -> { matches: NodeSummary[] }`
- `subscribe_events({}) -> stream of events`
- `vcs_history({ limit?: number, offset?: number }) -> { commits: {hash,message,timestamp}[] }` optional
- `vcs_push({}) -> { status }` optional
- `vcs_pull({}) -> { status }` optional
- `ping({}) -> { now: number }`

### 6.7 Limits and abuse protection

- Max payload size: 2 MB per message by default
- Server clamps `search.limit` to 500
- Server serializes `apply_ops` with a mutex
- Idle timeouts on subscriptions with periodic `ping`

### 6.8 Error codes

- `INVALID_REQUEST`, `UNSUPPORTED_VERSION`
- `NOT_FOUND`, `INVALID_PARENT`, `CYCLE_DETECTED`, `ROOT_IMMUTABLE`
- `VALIDATION_FAILED`, `OUT_OF_RANGE`
- `STORAGE_ERROR`, `VCS_ERROR`, `VCS_NOT_FAST_FORWARD`, `VCS_LOCAL_CHANGES_PRESENT`
- `PERMISSION_DENIED`

---

## 7. Daemon behavior

### 7.1 Concurrency model

- Single-writer critical section for any mutation path
- Read-only RPCs can proceed concurrently
- Event emission after successful commit

### 7.2 Apply sequence

1. Start SQLite transaction
2. Validate and apply ops
3. Commit SQLite
4. Export snapshot
5. Git add and commit
6. Emit `tree_changed` event

If Git commit fails:

- Set `vcsPending=true` in daemon state
- Return `ok: true` with `vcsStatus.pending=true`
- Background worker retries commit or logs permanent error

### 7.3 Startup, shutdown, and crash handling

- On startup, open SQLite and load Tree into memory
- If `snapshot.json` is missing, regenerate it
- If a stale socket path exists, check if a live daemon responds. Remove stale and bind if not
- On shutdown, close sockets, flush logs, and dispose resources

### 7.4 Logging

- Structured logs with levels
- Rotating file in `<profile>/log/`
- Include `traceId` in error responses to correlate with logs
- `--debug` flag for verbose logging in dev

---

## 8. Clients

### 8.1 macOS SwiftUI app

- Connects to Unix socket using a small Swift IPC client
- On launch: ensure daemon is running
- Displays sidebar tree with drag and drop
- Buttons: add folder, add bookmark, save session
- Settings: profile path, optional remote URL and key linking
- For App Store: use App Group container for DB and socket, use a login item helper via `SMAppService`

### 8.2 Safari app extension

- Minimal quick capture of current tab
- For sandboxed extension, route messages to containing app, which forwards to daemon

### 8.3 Chrome extension

- MV3 popup or side panel with quick capture
- Uses Native Messaging to talk to `bmd-bridge`
- `bmd-bridge` talks to daemon over socket or pipe
- Host manifest restricts `allowed_origins` to the extension ID

---

## 9. Configuration and profiles

### 9.1 Config file per profile

`<profile>/config.yaml`:

```yaml
profileName: default
storage:
  dbPath: ./state.db
vcs:
  enabled: true
  remote:
    url: git@host:repo.git
    branch: main
    autoPush: false
ipc:
  socketPath: ../ipc.sock
security:
  requireSharedSecret: false
```

### 9.2 Multiple profiles

- Each profile gets its own directory: repo, socket, config, logs
- Only one daemon may own a given profile at a time

---

## 10. Security model

- No network listener, only local IPC
- Socket directory permissions must be 0700
- Optional shared secret in IPC header if desired
- Remote credentials in platform secret stores
- No telemetry by default
- Threat model: an attacker with your user privileges can read files anyway. The design avoids widening remote attack surface

---

## 11. Performance targets

- Cold start: under 200 ms to become available for typical trees under 10k nodes
- `apply_ops`: under 50 ms for single adds, under 200 ms for typical move
- Search: under 50 ms for substring queries across 10k nodes
- Git commit: under 150 ms median on SSD. Outliers acceptable
- Memory: O(n) for in-memory tree, under 50 MB for 50k nodes

---

## 12. Import and export (optional v1.1)

- Import from standard HTML bookmarks file into a chosen folder
- Export `snapshot.json` and optional HTML
- Command-line tool `s0f import/export` for scripting

---

## 13. Testing and quality

### 13.1 Unit tests

- Core ops: success and validation failure cases
- Storage: apply ops round-trips, delete recursive, reorder stability
- IPC framing: length prefix encode or decode, error paths

### 13.2 Integration tests

- Spin up daemon against a temp profile, exercise RPCs end to end
- Git commits observed per batch, snapshot correctness

### 13.3 Property tests

- Random operation sequences must preserve tree invariants and never create cycles

### 13.4 Load tests

- Generate 50k nodes and measure search, move, and commit timings

### 13.5 Static checks

- `go vet`, `staticcheck`, `golangci-lint`
- SwiftLint for SwiftUI project

---

## 14. Build and packaging

### 14.1 Repository layout

```
.
├─ cmd/
│  ├─ bmd/                # daemon
│  └─ bmd-bridge/         # native messaging bridge
├─ pkg/
│  ├─ core/
│  ├─ storage/
│  │  └─ sqlite/
│  ├─ vcs/
│  │  └─ git/
│  ├─ ipc/
│  ├─ config/
│  └─ logging/
├─ ui/
│  ├─ macos/
│  │  └─ extension/
│  └─ chrome/
└─ docs/
```

### 14.2 macOS distribution

- Developer build: LaunchAgent or on-demand launch from app
- App Store build: app group container, login item helper, XPC or socket in group container
- Codesign all binaries

### 14.3 Chrome Native Messaging

- Host manifest path per platform
- Registry keys on Windows
- Restrict `allowed_origins`

---

## 15. Roadmap

### v1.0

- Daemon, SQLite, Git commits, IPC
- SwiftUI macOS app with core UX
- Quick capture on Safari or Chrome
- Manual push or pull, fast-forward only
- No multi-device merge

### v1.1

- Import or export flows
- Event subscriptions in clients
- CLI `s0f` for scripts
- Better reorder batching

### v2.0

- Multi-device merge using operation logs and app-level resolution
- Tags and notes with optional FTS5
- Encryption at rest and optional end-to-end sync envelopes

---

## 16. Open questions

- Do we want duplicate-title prevention per folder for hygiene
- Do we want a shared secret on IPC in v1, or just rely on path permissions
- How aggressive should reorder debouncing be on the UI side

---

## 17. Acceptance criteria

- Install daemon, start it, and create default profile
- macOS app connects, shows empty tree with root, creates and reorders items
- `apply_ops` updates SQLite and creates a Git commit with snapshot
- `search` returns expected results for titles and URLs
- Safari or Chrome quick capture adds a bookmark to selected folder
- Push to a configured remote fails on non fast-forward and returns a clear error
- Logs contain traceIds that map to error responses

---

## 18. Appendix

### 18.1 Sample RPC messages

`apply_ops` request:

```json
{
  "id": "7",
  "type": "apply_ops",
  "params": {
    "ops": [
      { "op": "add_folder", "parentId": "root", "title": "Reading" },
      {
        "op": "add_bookmark",
        "parentId": "root",
        "title": "SICP",
        "url": "https://mitpress.mit.edu/..."
      }
    ]
  }
}
```

Success:

```json
{
  "id": "7",
  "ok": true,
  "result": {
    "tree": {
      "version": "abc123",
      "rootId": "root",
      "nodes": { "...": "..." }
    },
    "vcsStatus": { "committed": true, "pushed": false, "pending": false }
  },
  "error": null,
  "traceId": "64b4e4c7..."
}
```

Validation error:

```json
{
  "id": "7",
  "ok": false,
  "result": null,
  "error": {
    "code": "INVALID_PARENT",
    "message": "Parent folder does not exist",
    "details": { "parentId": "fld_missing" }
  },
  "traceId": "64b4e4c7..."
}
```

Event:

```json
{
  "kind": "event",
  "event": "tree_changed",
  "version": "def456",
  "changedNodeIds": ["bm_42", "fld_3"]
}
```

### 18.2 Example SQL for recursive delete

- Enumerate descendants in Go and delete by `IN` list inside one transaction, or enable recursive CTE if allowed and use:

```sql
WITH RECURSIVE sub(id) AS (
  SELECT ?1
  UNION ALL
  SELECT n.id FROM nodes n JOIN sub s ON n.parent_id = s.id
)
DELETE FROM nodes WHERE id IN (SELECT id FROM sub);
```

### 18.3 Cycle detection on move

- Check ancestry in memory before updating DB
- Reject with `CYCLE_DETECTED` when `newParentId` is in the subtree of `nodeId`

---

This spec is intended to be the single source of truth for v1. If you want it split into separate files for Overview, Architecture, and Specs, say the word and I will produce those as well with this exact content partitioned across files.
